import numpy as np
gMission_edges = "Data/gMissionDataset/edges.txt"


class GMission:
    """
    Class for loading gMission dataset in its entirety. We use this class to generate new instances of the OLBM problem
    for training.
    """

    def __init__(self):
        """
        The gMission class contains three member variables: workers, tasks, and costs. Instances of the OLBM problem
        can be generated by calling self.generate_OLBM_instance
        """
        self.workers, self.tasks, self.costs = self._load()

    @staticmethod
    def _load():
        """
        :return (workers, tasks, cost) - workers is a set of all the workers, while tasks is a set
        of all tasks. The Costs is a worker by task cost array where the [worker][task]th item is
        the expected value of matching the worker to a task.
        """
        f_edges = open(gMission_edges, "r")
        edge_weights = dict()
        for line in f_edges:
            vals = line.split(",")
            edge_weights[vals[0]] = vals[1].strip()
        w = np.array(list(edge_weights.values()), dtype="float")
        max_w = max(w)
        edges = {k: (float(v) / float(max_w)) for k, v in edge_weights.items()}
        workers = np.array(list(set([int(float(key.split(";")[0])) for key in edges])))
        tasks = np.array(list(set([int(float(key.split(";")[1])) for key in edges])))
        cost = np.zeros((max(workers) + 1, max(tasks) + 1))
        for k, v in edges.items():
            i, j = k.split(";")
            i = int(float(i))
            j = int(float(j))
            cost[i][j] = v
        return workers, tasks, cost

    def generate_olbm_instance(self, num_tasks=50, num_workers=50, random_seed=1234):
        """
        Generate a training instance of the OLBM problem. This consists of 1) a list of tasks that are known at the
        beginning of the problem, 2) a list of workers that will be presented in sequence to the model that is
        attempting to perform matching, and 3) a weight matrix that essentially serves as a lookup table to calculate
        the value of matching the nth worker to each of the tasks we currently have assigned.

        To train our network, we essentially need to generate a lot of OLBM problems from the dataset. Each training
        instance consists of a randomly selected subset of tasks, workers, and the edges linking them.
        """
        np.random.seed(random_seed)
        # Randomly sample a set of tasks:
        random_tasks = self._random_sample_of_tasks(num_tasks)  # Pick a random set of tasks

        # Randomly sample a set of workers:
        random_workers = self._random_sample_of_workers(num_workers)

        # Get the edges matching the workers to those tasks
        edges = self.costs[random_workers, :][:, random_tasks]

        # Create a new OLBMInstance from the above:
        return OLBMInstance(random_tasks, random_workers, edges)

    def _random_sample_of_tasks(self, num_tasks):
        return self.tasks[np.random.choice(len(self.tasks), size=num_tasks, replace=False)]

    def _random_sample_of_workers(self, num_workers):
        return self.workers[np.random.choice(len(self.workers), size=num_workers, replace=False)]


class OLBMInstance:
    def __init__(self, tasks, workers, costs):
        self.tasks = np.array([i for i in range(len(tasks))])
        self.workers = np.array([i for i in range(len(workers))])
        self.costs = costs  # Weight matrix describing edges linking workers -> tasks. Rows are workers. Cols are tasks.
        self.step = 0  # increment that keeps track of where we are in the problem, i.e. which worker to present next
        self.matchings = {}  # Dict to keep track of which tasks have been matched with which worker
        self.matching_score = 0  # Keep track of value of current assigned matching
        self.matched_bitmap = np.ones_like(self.tasks, dtype=np.int8)  # Bitmap indicating which tasks have been

    def has_unseen_workers(self):
        return self.step < len(self.workers)

    def get_next_worker(self):
        if self.has_unseen_workers():
            worker_to_return = self.workers[self.step]
            self.step += 1
            return worker_to_return

    def get_next_nn_input(self):
        """
        Get the edge list for the next worker in the sequence and the bitmap representing the unmatched nodes and
        return them as a concatenated numpy vector representing the state of the problem at a given time-step.
        Also returns the worker to be matched.
        """
        worker = self.get_next_worker()
        worker_edges = self.costs[worker]
        return worker, np.concatenate((worker_edges, self.matched_bitmap))

    def get_matchings(self):
        return self.matchings

    def get_matched_bitmap(self):
        return self.matched_bitmap

    def get_worker_edges(self, worker):
        return self.costs[worker]

    def get_matching_score(self):
        return self.matching_score

    def get_all_edges(self):
        return self.costs

    def match(self, task, worker):
        """
        Attempt to match the input task to the input worker. The method returns the weight of the edge between the two
        as the "reward" for performing the matching. If there is no edge between the task and the worker, then matchin
        is not performed in the problem state and a reward of 0 is returned.
        """
        reward = 0
        if task >= len(self.tasks):
            return reward  # We are choosing to skip this worker in this case
        if self.costs[worker][task] > 0:  # Need to check if an edge exists, otherwise we can't perform a match
            self.matchings[task] = worker
            self.matched_bitmap[task] = 0
            self.matching_score += self.costs[worker][task]
            reward = self.costs[worker][task]
        return reward


# Test code to allow us to debug the above class:
if __name__ == '__main__':
    a = GMission()

    olbm_problem = a.generate_olbm_instance()
    matchings = olbm_problem.get_matchings()
    bitmap = olbm_problem.get_matched_bitmap()
    unseen_workers = olbm_problem.has_unseen_workers()
    next_worker = olbm_problem.get_next_worker()
    next_nn_input = olbm_problem.get_next_nn_input()

    olbm_problem.match(0, 8)
    matchings = olbm_problem.get_matchings()
    bitmap = olbm_problem.get_matched_bitmap()

    print("Test Finished")

