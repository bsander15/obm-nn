import numpy as np

gMission_edges = "gMissionDataset/edges.txt"

class gMission:
    """
    Class for loading gMission dataset in its entirety. We use this class to generate new instances of the OLBM problem
    for training.
    """
    def __init__(self):
        """
        The gMission class contains three member variables: workers, tasks, and costs. Instances of the OLBM problem
        can be generated by calling self.generate_OLBM_instance
        """
        self.workers, self.tasks, self.costs = self._load()

    def _load(self):
        """
        :return (workers, tasks, cost) - workers is a set of all the workers, while tasks is a set
        of all tasks. The Costs is a worker by task cost array where the [worker][task]th item is
        the expected value of matching the worker to a task.
        """
        f_edges = open(gMission_edges, "r")
        edgeWeights = dict()
        for line in f_edges:
            vals = line.split(",")
            edgeWeights[vals[0]] = vals[1].strip()
        w = np.array(list(edgeWeights.values()), dtype="float")
        max_w = max(w)
        edges = {k: (float(v) / float(max_w)) for k, v in edgeWeights.items()}
        workers = np.array(list(set([int(float(key.split(";")[0])) for key in edges])))
        tasks = np.array(list(set([int(float(key.split(";")[1])) for key in edges])))
        cost = np.zeros((max(workers)+1, max(tasks)+1))
        for k,v in edges.items():
            i,j = k.split(";")
            i = int(float(i))
            j = int(float(j))
            cost[i][j] = v
        return workers,tasks,cost

    def generate_OLBM_instance(self, num_tasks=50, num_workers = 50, random_seed=1234):
        """
        Generate a training instance of the OLBM problem. This consists of 1) a list of tasks that are known at the
        beginning of the problem, 2) a list of workers that will be presented in sequence to the model that is
        attempting to perform matching, and 3) a weight matrix that essentially serves as a lookup table to calculate
        the value of matching the nth worker to each of the tasks we currently have assigned.

        To train our network, we essentially need to generate a lot of OLBM problems from the dataset. Each training
        instance consists of a randomly selected subset of tasks, workers, and the edges linking them.
        """
        np.random.seed(random_seed)
        # Randomly sample a set of tasks:
        random_tasks = self._random_sample_of_tasks(num_tasks)  # Pick a random set of tasks

        # Randomly sample a set of workers:
        random_workers = self._random_sample_of_workers(num_workers)

        # Get the edges matching the workers to those tasks
        edges = self.costs[random_workers]

        # Create a new OLBMInstance from the above:
        return OLBMInstance(random_tasks, random_workers, edges)

    def _random_sample_of_tasks(self, num_tasks):
        return self.tasks[np.random.choice(len(self.tasks), size=num_tasks, replace=False)]

    def _random_sample_of_workers(self, num_workers):
        return self.workers[np.random.choice(len(self.workers), size=num_workers, replace=False)]




class OLBMInstance:
    def __init__(self, tasks, workers, costs):
        self.tasks = tasks
        self.workers = workers
        self.costs = costs
        self.step = 0  # increment that keeps track of where we are in the problem, i.e. which worker to present next
        self.matchings = {}  # Dict to keep track of which tasks have been matched with which worker
        self.matched_bitmap = np.ones_like(self.workers)  # Bitmap indicating which tasks have been

    def has_unseen_workers(self):
        return self.step < len(self.workers)

    def get_next_worker(self):
        if self.has_unseen_workers():
            worker_to_return = self.workers[self.step]
            self.step += 1
            return worker_to_return

    def get_next_NN_input(self):
        worker = self.get_next_worker()
        worker_edges = self.costs[worker]
        return np.concatenate((worker_edges, self.matched_bitmap))

    def get_matchings(self):
        return self.matchings

    def get_matched_bitmap(self):
        return self.matched_bitmap

    def match(self, task, worker):
        self.matchings[task] = worker
        self.matched_bitmap[task] = 0


# Test code to allow us to debug the above class:
if __name__ == '__main__':
    a = gMission()

    instance_for_OLBM = a.generate_OLBM_instance()

